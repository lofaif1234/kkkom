--
if not LPH_OBFUSCATED then
    LPH_JIT_MAX = function(...)
        return (...)
    end
    LPH_NO_VIRTUALIZE = function(...)
        return (...)
    end
end
--
do -- Folders

end
--
local Script = main_env().script
local Utility = {}
local Renderer, Visuals, Movement, Color, Math, Tween, Module = {
    Registry = {},
    Drawing = {},
    CurrentIdx = 0
}, {
    Bases = {},
    Base = {},
    
}, {
    Velocity = 0,
    State = {},
    LastPosition = CFrame.new()
}, {
}, {
    Conversions = {}
}, {
}, {
    Shared = {},
    Drawings = {},
    ToolConnections = {},
    Locals = {
        Bounding = false,
        LastTick = tick(),
        ShiftTick = tick(),
        LastStutter = tick(),
        TriggerTick = tick(),
        Shift = 0,
        AimAssistFOV = 360,
        DeadzoneFOV = 180,
        SilentFOV = 360,
        Speed = 0,
        MVector = Vector3.new(),
        Hit = Vector3.new(),
        Calibration = {
            Tick = tick(),
            Sample = nil,
            Accuracy = 0,
            Prediction = 0.12,
            TargetState = Enum.HumanoidStateType.Running,
            AdjustYDimension = nil,
            AutoVelocity = {
                A = nil,
                B0 = nil,
                v_t = nil,
                v_b = nil
            }
        },
        TriggerBotTarget = nil,
        AimAssistTarget = nil,
        SilentAimTarget = nil,
        TriggerState = false,
        Sample = nil,
        PartSizes = {
            ['Head'] = Vector3.new(2, 1, 1),
            ['Torso'] = Vector3.new(2, 2, 1),
            ['Left Arm'] = Vector3.new(1, 2, 1),
            ['Right Arm'] = Vector3.new(1, 2, 1),
            ['Left Leg'] = Vector3.new(1, 2, 1),
            ['Right Leg'] = Vector3.new(1, 2, 1)
        },
        Emojis = {'ğŸ˜€', 'ğŸ˜', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜…', 'ğŸ˜†', 'ğŸ˜Š', 'ğŸ˜', 'ğŸ™‚', 'ğŸ¤—', 'ğŸ¤©', 'ğŸ¤”', 'ğŸ¤¨', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ™„', 'ğŸ˜£', 'ğŸ˜¥', 'ğŸ˜®', 'ğŸ¤', 'ğŸ˜¯', 'ğŸ˜ª', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜´', 'ğŸ˜Œ', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ˜', 'ğŸ˜’', 'ğŸ¤¤', 'ğŸ˜“', 'ğŸ˜”', 'ğŸ˜•', 'ğŸ™ƒ', 'ğŸ¤‘', 'ğŸ˜²', 'ğŸ™', 'ğŸ˜–', 'ğŸ˜', 'ğŸ˜Ÿ', 'ğŸ˜¤', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜¦', 'ğŸ˜§', 'ğŸ˜¨', 'ğŸ˜©', 'ğŸ¤¯', 'ğŸ˜¬', 'ğŸ˜°', 'ğŸ˜±', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ˜³', 'ğŸ¤ª', 'ğŸ˜µ', 'ğŸ¥´', 'ğŸ˜ ', 'ğŸ˜¡', 'ğŸ¤¬', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•', 'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ˜‡', 'ğŸ¥³', 'ğŸ¥º', 'ğŸ¤ ', 'ğŸ¤¡', 'ğŸ¤¥', 'ğŸ¤«', 'ğŸ¤­', 'ğŸ§', 'ğŸ¤“', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ‘¹', 'ğŸ‘º', 'ğŸ’€', 'â˜ ', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ’©', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹', 'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ±â€', 'ğŸ‘¤', 'ğŸ±â€', 'ğŸ', 'ğŸ±â€ğŸ’»', 'ğŸ±â€', 'ğŸ‰', 'ğŸ±â€', 'ğŸ‘“', 'ğŸ±â€ğŸš€', 'ğŸ™ˆ', 'ğŸ™‰', 'ğŸ™Š', 'ğŸµ', 'ğŸ¶', 'ğŸº', 'ğŸ±', 'ğŸ¦', 'ğŸ¯', 'ğŸ¦’', 'ğŸ¦Š', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ—', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ»', 'ğŸ²', 'ğŸ”', 'ğŸ¦„', 'ğŸ´', 'ğŸ¦“', 'ğŸ¸', 'ğŸ¼', 'ğŸ¨', 'ğŸ½', 'ğŸ¾', 'ğŸ’', 'ğŸ¦', 'ğŸ¦§', 'ğŸ¦®', 'ğŸ•â€', 'ğŸ¦º', 'ğŸ©', 'ğŸ¦›', 'ğŸ¦', 'ğŸ¦Œ', 'ğŸ', 'ğŸ†', 'ğŸ…', 'ğŸˆ', 'ğŸ•', 'ğŸ‘€', 'ğŸ‘', 'ğŸ§ ', 'ğŸ¦¾', 'ğŸ¦¿', 'ğŸ‘£', 'ğŸ¤º', 'ğŸ•·', 'ğŸ•¸', 'ğŸ…', 'ğŸ‘²', 'ğŸ‘©â€ğŸ“', 'ğŸ‘¨â€ğŸ“', 'ğŸ†', 'ğŸ‡', 'ğŸ¨', 'ğŸª', 'ğŸ•¶', 'ğŸ‘“', 'ğŸ¥½', 'ğŸ€', 'ğŸ¥', 'ğŸ', 'âš¾', 'âš½', 'ğŸ’', 'ğŸ’', 'ğŸ’„', 'ğŸˆ', 'ğŸ‰', 'ğŸ±', 'ğŸ”Š', 'ğŸ”‰', 'ğŸ”ˆ', 'ğŸ“¢', 'ğŸ“£', 'ğŸ§', 'ğŸª•', 'ğŸ¸', 'ğŸº', 'ğŸ·', 'ğŸ»', 'âœ‚', 'ğŸ“', 'ğŸ“', 'ğŸ—ƒ', 'ğŸ•', 'ğŸ”', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¿', 'ğŸ§‚', 'ğŸ¥“', 'ğŸŒ®', 'ğŸŒ¯', 'ğŸ’'},
        Symbols = {'$', '!', 'Â£', '%', '^', '&', '*', '(', ')', '_', '-', '+', '=', '[', ']', '{', '}', '@', ':', ';', '/', '?', '<', '>'}
    },
    Games = {
        [1008451066] = {
            Name = 'Da Hood',
            Updater = 'UpdateMousePosI2',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    if (Player) and Player.Character:FindFirstChild('BodyEffects') then
                        return Player.Character.BodyEffects['K.O'].Value
                    end
                    --
                    return false
                end,
                GrabbedFunction = function(Player)
                    if Player and Player.Character then
                        if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') ~= nil then
                            return true
                        else
                            return false
                        end
                    else
                        return false
                    end
                end,			
                RemotePath = function()
                    return game:GetService("ReplicatedStorage"):FindFirstChild('MainEvent')
                end
            }
        },
        [1958807588] = {
            Name = 'Hood Modded', 
            Updater = 'MousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['Bullets']
                end
            }
        },
        [6903502848] = {
            Name = 'OG Da Hood',
            Updater = 'lenakistoptouchingme',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    if (Player) and Player.Character:FindFirstChild('BodyEffects') then
                        return Player.Character.BodyEffects['K.O'].Value
                    end
                    --
                    return false
                end,
                GrabbedFunction = function(Player)
                    if Player and Player.Character then
                        if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') ~= nil then
                            return true
                        else
                            return false
                        end
                    else
                        return false
                    end
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [3634139746] = {
            Name = 'Hood Customs',
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    if (Player) and Player.Character:FindFirstChild('BodyEffects') then
                        return Player.Character.BodyEffects['K.O'].Value
                    end
                    --
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6070070353] = {
            Name = 'The Hood Customs', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [5990512246] = {
            Name = 'Ar Hood', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6133438581] = {
            Name = 'Hood Spirit FFA', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6173397248] = {
            Name = '1v1 Hood 2',
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    if (Player) and Player.Character:FindFirstChild('BodyEffects') then
                        return Player.Character.BodyEffects['K.O'].Value
                    end
                    --
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [5403249584] = {
            Name = 'Flame Hood', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['.gg/flamehood']
                end
            }
        },
        [5235037897] = {
            Name = 'Da Strike', 
            Updater = 'MOUSE',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage.MAINEVENT
                end
            }
        },
        [5955726556] = {
            Name = 'Da Downhill', 
            Updater = 'MOUSE',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage.MAINEVENT
                end
            }
        },
        [6139677386] = {
            Name = 'Da Uphill', 
            Updater = 'MOUSE',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage.MAINEVENT
                end
            }
        },
        [6144889736] = {
            Name = 'Da Hills', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game:GetService('ReplicatedStorage'):FindFirstChild('assets'):FindFirstChild('dh'):FindFirstChild('MainEvent')
                end
            }
        },
        [6070798844] = {
            Name = 'Dee Hood', 
            Updater = 'UpdateMousePosI',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6256403293] = {
            Name = 'Der Hood', 
            Updater = 'FIRETHISIFYOUREASKID',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6816024364] = {
            Name = 'New Hood', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6069154695] = {
            Name = 'Bell Hood', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [5934929789] = {
            Name = 'Yeno Hood', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [5793036557] = {
            Name = 'Hood Z', 
            Updater = 'UpdateMousePos',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            }
        },
        [6035872082] = {
            Name = 'Rivals', 
            Mouse = true,
            Updater = 'N/A',
            HoodGame = true,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return 'N/A'
                end
            }
        },
        [595270616] = {
            Name = 'State Of Anarchy', 
            Mouse = true,
            Updater = 'N/A',
            HoodGame = false,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return 'N/A'
                end
            }
        },
        [115797356] = {
            Name = 'Counter Blox', 
            Mouse = true,
            Updater = 'N/A',
            HoodGame = false,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return 'N/A'
                end
            }
        },
        ['Universal'] = {
            Name = 'Universal',
            Updater = 'None',
            HoodGame = false,
            Functions = {
                KnockedFunction = function(Player)
                    return false
                end,
                GrabbedFunction = function(Player)
                    return false
                end,			
                RemotePath = function()
                    return game.ReplicatedStorage['MainEvent']
                end
            },
        }
    },
    Safe = true,
    Version = 'Streamproof',
    Connections = {},
    Account = {
        Username = (lgVarsTbl and lgVarsTbl['DiscordUsername'] or 'User'),
        UserID = 1
    }
}
--
local BoundingBoxes = { 
    [1] = {}, 
    [2] = {}
}
--
local CurrentGame
if Module.Games[game.GameId] then
    CurrentGame = Module.Games[game.GameId]
else
    CurrentGame = Module.Games['Universal']
end
--
local ReplicatedStorage, UserInputService, TeleportService, HttpService, RunService, Workspace, Lighting, CoreGui, Players, Teams, Stats = game:GetService('ReplicatedStorage'), game:GetService('UserInputService'), game:GetService('TeleportService'), game:GetService('HttpService'), game:GetService('RunService'), game:GetService('Workspace'), game:GetService('Lighting'), game:GetService('CoreGui'), game:GetService('Players'), game:GetService('Teams'), game:GetService('Stats')
--
local UserGameSettings = UserSettings():GetService('UserGameSettings')
local Network = settings():GetService('NetworkSettings')
--
local Client = Players.LocalPlayer
local Mouse = Client:GetMouse()
local Ping = Stats.PerformanceStats.Ping
local Camera = Workspace.CurrentCamera
--
local ResetMemoryCategory, SetMemoryCategory, SetUpvalueName, SetMetatable, ProfileBegin, GetMetatable, GetConstants, GetRegistry, GetUpvalues, GetConstant, SetConstant, GetUpvalue, ValidLevel, LoadModule, SetUpvalue, ProfileEnd, GetProtos, GetLocals, Traceback, SetStack, GetLocal, DumpHeap, GetProto, SetLocal, GetStack, GetFenv, GetInfo, Info = debug.resetmemorycategory, debug.setmemorycategory, debug.setupvaluename, debug.setmetatable, debug.profilebegin, debug.getmetatable, debug.getconstants, debug.getregistry, debug.getupvalues, debug.getconstant, debug.setconstant, debug.getupvalue, debug.validlevel, debug.loadmodule, debug.setupvalue, debug.profileend, debug.getprotos, debug.getlocals, debug.traceback, debug.setstack, debug.getlocal, debug.dumpheap, debug.getproto, debug.setlocal, debug.getstack, debug.getfenv, debug.getinfo, debug.info
local RandomSeed, Random, Frexp, Floor, Atan2, Log10, Noise, Round, Ldexp, Clamp, Sinh, Sign, Asin, Acos, Fmod, Huge, Tanh, Sqrt, Atan, Modf, Ceil, Cosh, Deg, Min, Log, Cos, Exp, Max, Rad, Abs, Pow, Sin, Tan, Pi = math.randomseed, math.random, math.frexp, math.floor, math.atan2, math.log10, math.noise, math.round, math.ldexp, math.clamp, math.sinh, math.sign, math.asin, math.acos, math.fmod, math.huge, math.tanh, math.sqrt, math.atan, math.modf, math.ceil, math.cosh, math.deg, math.min, math.log, math.cos, math.exp, math.max, math.rad, math.abs, math.pow, math.sin, math.tan, math.pi
local Foreachi, Isfrozen, Foreach, Insert, Remove, Concat, Freeze, Create, Unpack, Clear, Clone, Maxn, Move, Pack, Find, Sort, Getn = table.foreachi, table.isfrozen, table.foreach, table.insert, table.remove, table.concat, table.freeze, table.create, table.unpack, table.clear, table.clone, table.maxn, table.move, table.pack, table.find, table.sort, table.getn
local PackSize, Reverse, SUnpack, Gmatch, Format, Lower, Split, Match, Upper, Byte, Char, Pack, Gsub, SFind, Rep, Sub, Len = string.packsize, string.reverse, string.unpack, string.gmatch, string.format, string.lower, string.split, string.match, string.upper, string.byte, string.char, string.pack, string.gsub, string.find, string.rep, string.sub, string.len
local Countlz, Rrotate, Replace, Lrotate, Countrz, Arshift, Extract, Lshift, Rshift, Btest, Band, Bnot, Bxor, Bor = bit32.countlz, bit32.rrotate, bit32.replace, bit32.lrotate, bit32.countrz, bit32.arshift, bit32.extract, bit32.lshift, bit32.rshift, bit32.btest, bit32.band, bit32.bnot, bit32.bxor, bit32.bor
local NfcNormalize, NfdNormalize, CharPattern, CodePoint, Graphemes, Offset, Codes, Char, Len = utf8.nfcnormalize, utf8.nfdnormalize, utf8.charpattern, utf8.codepoint, utf8.graphemes, utf8.offset, utf8.codes, utf8.char, utf8.len
local Isyieldable, Running, Status, Create, Resume, Close, Yield, Wrap = coroutine.isyieldable, coroutine.running, coroutine.status, coroutine.create, coroutine.resume, coroutine.close, coroutine.yield, coroutine.wrap
local Desynchronize, Synchronize, Cancel, Delay, Defer, Spawn, Wait = task.desynchronize, task.synchronize, task.cancel, task.delay, task.defer, task.spawn, task.wait
local Offset = game:GetService('GuiService'):GetGuiInset().Y
local AimingFOVObject, SilentFOVObject = nil, nil
local GradientOne = Color3.fromRGB(181, 83, 93)  
local GradientTwo = Color3.fromRGB(128, 0, 128) 
local GradientThree = Color3.fromRGB(83, 106, 181) 
local Find = table.find
local Weapons = {
    Shotguns = {
        "[Double-Barrel SG]",
        "[TacticalShotgun]",
        "[Shotgun]"
    },
    Pistols = {
        "[Revolver]",
        "[Glock]",
        "[Silencer]"
    }
}
--
local function CreateRenderObject(Class)
    return Renderer.Drawing.new(Class)
end
--
local function DestroyRenderObject(Drawing)
    Drawing:Remove()
end
--
local function SetRenderProperty(Object, Index, Value)
    Object[Index] = Value
end
--
local function GetRenderProperty(Class, Index)
    return Class[Index]
end
--
do -- Drawing [[disabled, parent set to nil for security]]
    local TestingLibrary = {}
    local DrawingTestingLibrary = {}
    local TestingLibraryUI = Instance.new('ScreenGui')
    --
	if not TestingLibrary.Font then
		TestingLibrary.Font = nil
	end
	--
	TestingLibraryUI.Name = '_ModuleDRAWING'
	TestingLibraryUI.IgnoreGuiInset = true
	TestingLibraryUI.DisplayOrder = 0x7fffffff
	TestingLibraryUI.Parent = nil
	--
	local _ModuleDRAWINGIndex = 0
	local LibraryMeta = setmetatable({
		Visible = true,
		ZIndex = 0,
		Transparency = 1,
		Color = Color3.new(),
		Remove = function(self)
			setmetatable(self, nil)
		end,
		Destroy = function(self)
			setmetatable(self, nil)
		end
	}, {
		__add = function(t1, t2)
			local result = table.clone(t1)

			for index, value in t2 do
				result[index] = value
			end
			return result
		end
	})
	--
	local function convertTransparency(number)
		return math.clamp(1 - number, 0, 1)
	end
	--
	function DrawingTestingLibrary.new(ClassType)
		_ModuleDRAWINGIndex += 1
		if ClassType == 'Line' then
			local lineObj = ({
				From = Vector2.zero,
				To = Vector2.zero,
				Thickness = 1
			} + LibraryMeta)

			local lineFrame = Instance.new('Frame')
			lineFrame.Name = _ModuleDRAWINGIndex
			lineFrame.AnchorPoint = (Vector2.one * .5)
			lineFrame.BorderSizePixel = 0

			lineFrame.BackgroundColor3 = lineObj.Color
			lineFrame.Visible = lineObj.Visible
			lineFrame.ZIndex = lineObj.ZIndex
			lineFrame.BackgroundTransparency = convertTransparency(lineObj.Transparency)

			lineFrame.Size = UDim2.new()

			lineFrame.Parent = TestingLibraryUI
			return setmetatable(table.create(0), {
				__newindex = function(_, index, value)
					if typeof(lineObj[index]) == 'nil' then return end

					if index == 'From' then
						local direction = (lineObj.To - value)
						local center = (lineObj.To + value) / 2
						local distance = direction.Magnitude
						local theta = math.deg(math.atan2(direction.Y, direction.X))

						lineFrame.Position = UDim2.fromOffset(center.X, center.Y)
						lineFrame.Rotation = theta
						lineFrame.Size = UDim2.fromOffset(distance, lineObj.Thickness)
					elseif index == 'To' then
						local direction = (value - lineObj.From)
						local center = (value + lineObj.From) / 2
						local distance = direction.Magnitude
						local theta = math.deg(math.atan2(direction.Y, direction.X))

						lineFrame.Position = UDim2.fromOffset(center.X, center.Y)
						lineFrame.Rotation = theta
						lineFrame.Size = UDim2.fromOffset(distance, lineObj.Thickness)
					elseif index == 'Thickness' then
						local distance = (lineObj.To - lineObj.From).Magnitude

						lineFrame.Size = UDim2.fromOffset(distance, value)
					elseif index == 'Visible' then
						lineFrame.Visible = value
					elseif index == 'ZIndex' then
						lineFrame.ZIndex = value
					elseif index == 'Transparency' then
						lineFrame.BackgroundTransparency = convertTransparency(value)
					elseif index == 'Color' then
						lineFrame.BackgroundColor3 = value
					end
					lineObj[index] = value
				end,
				__index = function(self, index)
					if index == 'Remove' or index == 'Destroy' then
						return function()
							lineFrame:Destroy()
							lineObj.Remove(self)
							return lineObj:Remove()
						end
					end
					return lineObj[index]
				end,
				__tostring = function() return '_ModuleDRAWING' end
			})
		elseif ClassType == 'Text' then
			local textObj = ({
				Text = '',
				Font = Enum.Font.SourceSansBold,
				Size = 0,
				Position = Vector2.zero,
				Center = false,
				Outline = false,
				OutlineColor = Color3.new()
			} + LibraryMeta)

			local textLabel, uiStroke = Instance.new('TextLabel'), Instance.new('UIStroke')
			textLabel.Name = _ModuleDRAWINGIndex
			textLabel.AnchorPoint = (Vector2.one * .5)
			textLabel.BorderSizePixel = 0
			textLabel.BackgroundTransparency = 1

			textLabel.Visible = textObj.Visible
			textLabel.TextColor3 = textObj.Color
			textLabel.TextTransparency = convertTransparency(textObj.Transparency)
			textLabel.ZIndex = textObj.ZIndex

			textLabel.TextSize = textObj.Size

			textLabel:GetPropertyChangedSignal('TextBounds'):Connect(function()
				local textBounds = textLabel.TextBounds
				local offset = textBounds / 2

				textLabel.Size = UDim2.fromOffset(textBounds.X, textBounds.Y)
				textLabel.Position = UDim2.fromOffset(textObj.Position.X + (if not textObj.Center then offset.X else 0), textObj.Position.Y + offset.Y)
			end)

			uiStroke.Thickness = 1
			uiStroke.Enabled = textObj.Outline
			uiStroke.Color = textObj.Color

			textLabel.Parent, uiStroke.Parent = TestingLibraryUI, textLabel
			return setmetatable(table.create(0), {
				__newindex = function(_, index, value)
					if typeof(textObj[index]) == 'nil' then return end

					if index == 'Text' then
						textLabel.Text = value
					elseif index == 'Size' then
						textLabel.TextSize = value
					elseif index == 'Position' then
						local offset = textLabel.TextBounds / 2

						textLabel.Position = UDim2.fromOffset(value.X + (if not textObj.Center then offset.X else 0), value.Y + offset.Y)
					elseif index == 'Center' then
						local position = (
							if value then
								workspace.CurrentCamera.ViewportSize / 2
								else
								textObj.Position
						)

						textLabel.Position = UDim2.fromOffset(position.X, position.Y)
					elseif index == 'Outline' then
						uiStroke.Enabled = value
					elseif index == 'OutlineColor' then
						uiStroke.Color = value
					elseif index == 'Visible' then
						textLabel.Visible = value
					elseif index == 'ZIndex' then
						textLabel.ZIndex = value
					elseif index == 'Transparency' then
						local transparency = convertTransparency(value)

						textLabel.TextTransparency = transparency
						uiStroke.Transparency = transparency
					elseif index == 'Color' then
						textLabel.TextColor3 = value
					end
					textObj[index] = value
				end,
				__index = function(self, index)
					if index == 'Remove' or index == 'Destroy' then
						return function()
							textLabel:Destroy()
							textObj.Remove(self)
							return textObj:Remove()
						end
					elseif index == 'TextBounds' then
						return textLabel.TextBounds
					end
					return textObj[index]
				end,
				__tostring = function() return '_ModuleDRAWING' end
			})
		elseif ClassType == 'Circle' then
			local circleObj = ({
				Radius = 150,
				Position = Vector2.zero,
				Thickness = .7,
				Filled = false
			} + LibraryMeta)

			local circleFrame, uiCorner, uiStroke = Instance.new('Frame'), Instance.new('UICorner'), Instance.new('UIStroke')
			circleFrame.Name = _ModuleDRAWINGIndex
			circleFrame.AnchorPoint = (Vector2.one * .5)
			circleFrame.BorderSizePixel = 0

			circleFrame.BackgroundTransparency = (if circleObj.Filled then convertTransparency(circleObj.Transparency) else 1)
			circleFrame.BackgroundColor3 = circleObj.Color
			circleFrame.Visible = circleObj.Visible
			circleFrame.ZIndex = circleObj.ZIndex

			uiCorner.CornerRadius = UDim.new(1, 0)
			circleFrame.Size = UDim2.fromOffset(circleObj.Radius, circleObj.Radius)

			uiStroke.Thickness = circleObj.Thickness
			uiStroke.Enabled = not circleObj.Filled
			uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

			circleFrame.Parent, uiCorner.Parent, uiStroke.Parent = TestingLibraryUI, circleFrame, circleFrame
			return setmetatable(table.create(0), {
				__newindex = function(_, index, value)
					if typeof(circleObj[index]) == 'nil' then return end

					if index == 'Radius' then
						local radius = value * 2
						circleFrame.Size = UDim2.fromOffset(radius, radius)
					elseif index == 'Position' then
						circleFrame.Position = UDim2.fromOffset(value.X, value.Y)
					elseif index == 'Thickness' then
						value = math.clamp(value, .6, 0x7fffffff)
						uiStroke.Thickness = value
					elseif index == 'Filled' then
						circleFrame.BackgroundTransparency = (if value then convertTransparency(circleObj.Transparency) else 1)
						uiStroke.Enabled = not value
					elseif index == 'Visible' then
						circleFrame.Visible = value
					elseif index == 'ZIndex' then
						circleFrame.ZIndex = value
					elseif index == 'Transparency' then
						local transparency = convertTransparency(value)

						circleFrame.BackgroundTransparency = (if circleObj.Filled then transparency else 1)
						uiStroke.Transparency = transparency
					elseif index == 'Color' then
						circleFrame.BackgroundColor3 = value
						uiStroke.Color = value
					end
					circleObj[index] = value
				end,
				__index = function(self, index)
					if index == 'Remove' or index == 'Destroy' then
						return function()
							circleFrame:Destroy()
							circleObj.Remove(self)
							return circleObj:Remove()
						end
					end
					return circleObj[index]
				end,
				__tostring = function() return '_ModuleDRAWING' end
			})
		elseif ClassType == 'Square' then
			local squareObj = ({
                Visible = false,
				Size = Vector2.zero,
				Position = Vector2.zero,
				Thickness = .7,
				Filled = false
			} + LibraryMeta)

			local squareFrame, uiStroke = Instance.new('Frame'), Instance.new('UIStroke')
			squareFrame.Name = _ModuleDRAWINGIndex
			squareFrame.BorderSizePixel = 0

			squareFrame.BackgroundTransparency = (if squareObj.Filled then convertTransparency(squareObj.Transparency) else 1)
			squareFrame.ZIndex = squareObj.ZIndex
			squareFrame.BackgroundColor3 = squareObj.Color
			squareFrame.Visible = squareObj.Visible

			uiStroke.Thickness = squareObj.Thickness
			uiStroke.Enabled = not squareObj.Filled
			uiStroke.LineJoinMode = Enum.LineJoinMode.Miter

			squareFrame.Parent, uiStroke.Parent = TestingLibraryUI, squareFrame
			return setmetatable(table.create(0), {
				__newindex = function(_, index, value)
					if typeof(squareObj[index]) == 'nil' then return end

					if index == 'Size' then
						squareFrame.Size = UDim2.fromOffset(value.X, value.Y)
					elseif index == 'Position' then
						squareFrame.Position = UDim2.fromOffset(value.X, value.Y)
					elseif index == 'Thickness' then
						value = math.clamp(value, 0.6, 0x7fffffff)
						uiStroke.Thickness = value
					elseif index == 'Filled' then
						squareFrame.BackgroundTransparency = (if value then convertTransparency(squareObj.Transparency) else 1)
						uiStroke.Enabled = not value
					elseif index == 'Visible' then
						squareFrame.Visible = value
					elseif index == 'ZIndex' then
						squareFrame.ZIndex = value
					elseif index == 'Transparency' then
						local transparency = convertTransparency(value)

						squareFrame.BackgroundTransparency = (if squareObj.Filled then transparency else 1)
						uiStroke.Transparency = transparency
					elseif index == 'Color' then
						uiStroke.Color = value
						squareFrame.BackgroundColor3 = value
					end
					squareObj[index] = value
				end,
				__index = function(self, index)
					if index == 'Remove' or index == 'Destroy' then
						return function()
							squareFrame:Destroy()
							squareObj.Remove(self)
							return squareObj:Remove()
						end
					end
					return squareObj[index]
				end,
				__tostring = function() return '_ModuleDRAWING' end
			})
		elseif ClassType == 'Image' then
			local imageObj = ({
				Data = '',
				DataURL = 'rbxassetid://0',
				Size = Vector2.zero,
				Position = Vector2.zero
			} + LibraryMeta)

			local imageFrame = Instance.new('ImageLabel')
			imageFrame.Name = _ModuleDRAWINGIndex
			imageFrame.BorderSizePixel = 0
			imageFrame.ScaleType = Enum.ScaleType.Stretch
			imageFrame.BackgroundTransparency = 1

			imageFrame.Visible = imageObj.Visible
			imageFrame.ZIndex = imageObj.ZIndex
			imageFrame.ImageTransparency = convertTransparency(imageObj.Transparency)
			imageFrame.ImageColor3 = imageObj.Color

			imageFrame.Parent = TestingLibraryUI
			return setmetatable(table.create(0), {
				__newindex = function(_, index, value)
					if typeof(imageObj[index]) == 'nil' then return end

					if index == 'Data' then
						-- later
					elseif index == 'DataURL' then 
						imageFrame.Image = value
					elseif index == 'Size' then
						imageFrame.Size = UDim2.fromOffset(value.X, value.Y)
					elseif index == 'Position' then
						imageFrame.Position = UDim2.fromOffset(value.X, value.Y)
					elseif index == 'Visible' then
						imageFrame.Visible = value
					elseif index == 'ZIndex' then
						imageFrame.ZIndex = value
					elseif index == 'Transparency' then
						imageFrame.ImageTransparency = convertTransparency(value)
					elseif index == 'Color' then
						imageFrame.ImageColor3 = value
					end
					imageObj[index] = value
				end,
				__index = function(self, index)
					if index == 'Remove' or index == 'Destroy' then
						return function()
							imageFrame:Destroy()
							imageObj.Remove(self)
							return imageObj:Remove()
						end
					elseif index == 'Data' then
						return nil 
					end
					return imageObj[index]
				end,
				__tostring = function() return '_ModuleDRAWING' end
			})
		elseif ClassType == 'Quad' then
			local QuadProperties = ({
				Thickness = 1,
				PointA = Vector2.new();
				PointB = Vector2.new();
				PointC = Vector2.new();
				PointD = Vector2.new();
				Filled = false;
			}  + LibraryMeta);

			local PointA = DrawingTestingLibrary.new('Line')
			local PointB = DrawingTestingLibrary.new('Line')
			local PointC = DrawingTestingLibrary.new('Line')
			local PointD = DrawingTestingLibrary.new('Line')

			return setmetatable({}, {
				__newindex = (function(self, Property, Value)
					if Property == 'Thickness' then
						PointA.Thickness = Value
						PointB.Thickness = Value
						PointC.Thickness = Value
						PointD.Thickness = Value
					end
					if Property == 'PointA' then
						PointA.From = Value
						PointB.To = Value
					end
					if Property == 'PointB' then
						PointB.From = Value
						PointC.To = Value
					end
					if Property == 'PointC' then
						PointC.From = Value
						PointD.To = Value
					end
					if Property == 'PointD' then
						PointD.From = Value
						PointA.To = Value
					end
					if Property == 'Visible' then 
						PointA.Visible = true
						PointB.Visible = true
						PointC.Visible = true
						PointD.Visible = true    
					end
					if Property == 'Filled' then
	
					end
					if Property == 'Color' then
						PointA.Color = Value
						PointB.Color = Value
						PointC.Color = Value
						PointD.Color = Value
					end
					if (Property == 'ZIndex') then
						PointA.ZIndex = Value
						PointB.ZIndex = Value
						PointC.ZIndex = Value
						PointD.ZIndex = Value
					end
				end),
				__index = (function(self, Property)
					if (string.lower(tostring(Property)) == 'remove') then
						return (function()
							PointA:Remove();
							PointB:Remove();
							PointC:Remove();
							PointD:Remove();
						end)
					end

					return QuadProperties[Property]
				end)
			});
		elseif ClassType == 'Triangle' then
			local triangleObj = ({
				PointA = Vector2.zero,
				PointB = Vector2.zero,
				PointC = Vector2.zero,
				Thickness = 1,
				Filled = false
			} + LibraryMeta)

			local _linePoints = table.create(0)
			_linePoints.A = DrawingTestingLibrary.new('Line')
			_linePoints.B = DrawingTestingLibrary.new('Line')
			_linePoints.C = DrawingTestingLibrary.new('Line')
			return setmetatable(table.create(0), {
				__tostring = function() return '_ModuleDRAWING' end,
				__newindex = function(_, index, value)
					if typeof(triangleObj[index]) == 'nil' then return end

					if index == 'PointA' then
						_linePoints.A.From = value
						_linePoints.B.To = value
					elseif index == 'PointB' then
						_linePoints.B.From = value
						_linePoints.C.To = value
					elseif index == 'PointC' then
						_linePoints.C.From = value
						_linePoints.A.To = value
					elseif (index == 'Thickness' or index == 'Visible' or index == 'Color' or index == 'ZIndex') then
						for _, linePoint in _linePoints do
							linePoint[index] = value
						end
					elseif index == 'Filled' then
						
					end
					triangleObj[index] = value
				end,
				__index = function(self, index)
					if index == 'Remove' or index == 'Destroy' then
						return function()
							for _, linePoint in _linePoints do
								linePoint:Remove()
							end

							triangleObj.Remove(self)
							return triangleObj:Remove()
						end
					end
					return triangleObj[index]
				end,
			})
		end
	end
	Renderer.Drawing = DrawingTestingLibrary
end
--
do -- Renderer
    function Renderer.new(Class, Name, Properties)
        local ValidTypes = {Circle = true, Square = true, Text = true, Line = true, Triangle = true}
        --
        if not ValidTypes[Class] then
            warn('[RENDERER]: Invalid Class')
            return
        end
        --
        if not Renderer.Registry[Name] then
            local Object = CreateRenderObject(Class)
            --
            for Index, Property in pairs(Properties) do
                if Object[Index] ~= nil then
                    Object[Index] = Property
                end
            end
            --
            Renderer.CurrentIdx += 1
            Renderer.Registry[Name] = Object
            --
            return Object
        end
    end    
end
--
do -- Utility
    function Utility:ThreadFunction(Func, Name, ...)
        local Func = Name and function()
            local Passed, Statement = pcall(Func)
            --
            if not Passed and not Module.Safe then
                warn('Module:\n', '              ' .. Name .. ':', Statement)
            end
        end or Func
        local Thread = Create(Func)
        --
        Resume(Thread, ...)
        return Thread
    end
    --
    function Module:Wrap(Func, ...)
        coroutine.wrap(Func)(...)
    end
    --
    function Utility:Connection(connectionType, connectionCallback)
        local connection = connectionType:Connect(connectionCallback)
        Module.Connections[#Module.Connections + 1] = connection
        --
        return connection
    end
    --
    function Utility:Construct(DataType, Table, Multiply)
        if DataType == 'Vector3' or DataType == '3D' then
            if Multiply then
                return Vector3.new(Table.X * Multiply, Table.Y * Multiply, Table.Z * Multiply)
            else
                return Vector3.new(Table.X, Table.Y, Table.Z)
            end
        end
        --
        if DataType == 'Vector2' or DataType == '2D' then
            if Multiply then
                return Vector2.new(Table.X * Multiply, Table.Y * Multiply)
            else
                return Vector2.new(Table.X, Table.Y)
            end
        end
    end
    --
    function Utility:IsPointInDrawing(Object, Type, Point, OverridePosition)
        if Type == 'Square' then
            local Position = OverridePosition or Object.Position
            local Size = Object.Size

            return Point.X >= Position.X and Point.X <= Position.X + Size.X and Point.Y >= Position.Y and Point.Y <= Position.Y + Size.Y
        elseif Type == 'Circle' then
            local Position = OverridePosition or Object.Position

            return (Position - Point).Magnitude <= Object.Radius
        elseif Type == 'Triangle' then
            local PointA = Object.PointA
            local PointB = Object.PointB
            local PointC = Object.PointC
            local AS = Point - PointA
            local AB = (PointB - PointA):Cross(AS) > 0

            if ((PointC - PointA):Cross(AS) > 0) == AB then
                return false
            end
            if ((PointC - PointB):Cross(Point - PointB) > 0) ~= AB then
                return false
            end

            return true
        end

        return false
    end
    --
    function Utility:Sleep()
        local Start = tick()
        ReplicatedStorage.DefaultChatSystemChatEvents.MutePlayerRequest:InvokeServer()
        return (tick() - Start) * 1000 / 0.5
    end
    --
    function Utility:InterpolateColor(color1, color2, t)
        return Color3.new(
            color1.R + (color2.R - color1.R) * t,
            color1.G + (color2.G - color1.G) * t,
            color1.B + (color2.B - color1.B) * t
        )
    end
    --
    function Utility:GetDynamicColor(t)
        if t < 0.33 then
            return Utility:InterpolateColor(GradientOne, GradientTwo, t * 3) 
        elseif t < 0.66 then
            return Utility:InterpolateColor(GradientTwo, GradientThree, (t - 0.33) * 3) 
        else
            return Utility:InterpolateColor(GradientThree, GradientOne, (t - 0.66) * 3)  
        end
    end
end
--
do -- Visuals
    do -- Drawing Objects
        AimingFOVObject = {} --Renderer.Drawing.new('Circle')
        SilentFOVObject = {} --Renderer.Drawing.new('Circle')
        --
        AimingFOVObject.Visible = Script['Camera Aimbot']['FOV']['Visible']
        AimingFOVObject.Size = Script['Camera Aimbot']['FOV']['Size'] * 100
        AimingFOVObject.Filled = Script['Camera Aimbot']['FOV'].Filled
        AimingFOVObject.Transparency = Script['Camera Aimbot']['FOV'].Transparency
        --
        SilentFOVObject.Visible = Script['Silent Aimbot']['FOV']['Visible']
        SilentFOVObject.Size = Module.Locals.SilentFOV
        SilentFOVObject.Filled = Script['Silent Aimbot']['FOV'].Filled
        SilentFOVObject.Transparency = Script['Silent Aimbot']['FOV'].Transparency
    end
    --
    function Visuals:UpdateBox()
		if Module.Locals.SilentAimTarget and Module.Locals.SilentAimTarget.Character then
            local Vector3new = Vector3.new
            local Vector2new = Vector2.new
            local Size = {
                Width = Script['Silent Aimbot']['FOV']['2D FOV']['Width'],
                Height = Script['Silent Aimbot']['FOV']['2D FOV']['Height']
            }
			local Object, Humanoid, RootPart = Module:ValidateClient(Module.Locals.SilentAimTarget)
			if (Object and Humanoid and RootPart) then		
				local Position = RootPart.Position;
				
				local Screen, Visible = Camera:WorldToViewportPoint(Position)
				if Visible then
					local Color = Color3.fromRGB(255, 255, 255);
					--
					local CharacterSize = (Camera:WorldToViewportPoint(RootPart.Position - Vector3new(0, 3, 0)).Y - 
					Camera:WorldToViewportPoint(RootPart.Position + Vector3new(0, 2.6, 0)).Y) / 2
					--
					local BoxWidth = Floor(CharacterSize * Size.Width)
					local BoxHeight = Floor(CharacterSize * Size.Height)
					local BoxPosition = Vector2new(Screen.X - BoxWidth / 2, Screen.Y - BoxHeight / 2 + 5)
					--
					local CF = Camera.ViewportSize
					if (Math:FlatComparison(Vector2new(CF.X / 2, CF.Y / 2), BoxPosition, Vector2new(BoxWidth, BoxHeight))) then
                        Module.Locals.Bounding = true
                    else
                        Module.Locals.Bounding = false
                    end
					--
					local L_Width = (BoxWidth / 5)
					local L_Height = (BoxHeight / 6)
					local L_T = 2
					--
					if #BoundingBoxes[1] == 0 then
						for i = 1, 16 do
                            local Line = CreateRenderObject("Line")
                            Line.Thickness = 1
                            Line.Color = Color3.fromRGB(120, 168, 231)
                            Line.Transparency = 1
							table.insert(BoundingBoxes[1], Line)
						end
					end
					-- Top left
					BoundingBoxes[1][1].From = Vector2new(BoxPosition.X - L_T, BoxPosition.Y - L_T)
					BoundingBoxes[1][1].To = Vector2new(BoxPosition.X + L_Width, BoxPosition.Y - L_T)
					
					BoundingBoxes[1][2].From = Vector2new(BoxPosition.X - L_T, BoxPosition.Y - L_T)
					BoundingBoxes[1][2].To = Vector2new(BoxPosition.X - L_T, BoxPosition.Y + L_Height)
					
					-- Top right
					BoundingBoxes[1][3].From = Vector2new(BoxPosition.X + BoxWidth - L_Width, BoxPosition.Y - L_T)
					BoundingBoxes[1][3].To = Vector2new(BoxPosition.X + BoxWidth + L_T, BoxPosition.Y - L_T)
					
					BoundingBoxes[1][4].From = Vector2new(BoxPosition.X + BoxWidth + L_T, BoxPosition.Y - L_T)
					BoundingBoxes[1][4].To = Vector2new(BoxPosition.X + BoxWidth + L_T, BoxPosition.Y + L_Height)
					
					-- Bottom left
					BoundingBoxes[1][5].From = Vector2new(BoxPosition.X - L_T, BoxPosition.Y + BoxHeight - L_Height)
					BoundingBoxes[1][5].To = Vector2new(BoxPosition.X - L_T, BoxPosition.Y + BoxHeight + L_T)
					
					BoundingBoxes[1][6].From = Vector2new(BoxPosition.X - L_T, BoxPosition.Y + BoxHeight + L_T)
					BoundingBoxes[1][6].To = Vector2new(BoxPosition.X + L_Width, BoxPosition.Y + BoxHeight + L_T)
					
					-- Bottom right
					BoundingBoxes[1][7].From = Vector2new(BoxPosition.X + BoxWidth - L_Width, BoxPosition.Y + BoxHeight + L_T)
					BoundingBoxes[1][7].To = Vector2new(BoxPosition.X + BoxWidth + L_T, BoxPosition.Y + BoxHeight + L_T)
					
					BoundingBoxes[1][8].From = Vector2new(BoxPosition.X + BoxWidth + L_T, BoxPosition.Y + BoxHeight + L_T)
					BoundingBoxes[1][8].To = Vector2new(BoxPosition.X + BoxWidth + L_T, BoxPosition.Y + BoxHeight - L_Height)
					--
					for _, Line in ipairs(BoundingBoxes[1]) do
						Line.Visible = Script['Silent Aimbot']['FOV']['Visible']
						Line.Color = Color
						Line.Transparency = 1
						Line.Thickness = 1
					end
				else
					for _, Line in ipairs(BoundingBoxes[1]) do
						Line:Remove()
					end
					BoundingBoxes[1] = {}
				end
			else
				for _, Line in ipairs(BoundingBoxes[1]) do
					Line:Remove()
				end
				BoundingBoxes[1] = {}
			end
		else
			for _, Line in ipairs(BoundingBoxes[1]) do
				Line:Remove()
			end
			BoundingBoxes[1] = {}
		end
	end
    --
    function Visuals:Update()
        local TName = Module:GetEquippedWeaponName(Client)
        if TName then
            if table.find(Weapons.Shotguns, TName) then
                Module.Locals.SilentFOV = Script['Silent Aimbot']['FOV']['Weapon Configuration']['Shotguns']['Size'] * 100
            elseif table.find(Weapons.Pistols, TName) then
                Module.Locals.SilentFOV = Script['Silent Aimbot']['FOV']['Weapon Configuration']['Pistols']['Size'] * 100
            else
                Module.Locals.SilentFOV = Script['Silent Aimbot']['FOV']['Weapon Configuration']['Others']['Size'] * 100
            end
        else
            Module.Locals.SilentFOV = Script['Silent Aimbot']['FOV']['Weapon Configuration']['Others']['Size'] * 100
        end
        --
        AimingFOVObject.Visible = Script['Camera Aimbot']['FOV']['Visible']
        AimingFOVObject.Radius = Script['Camera Aimbot']['FOV']['Size'] * 100
        AimingFOVObject.Filled = Script['Camera Aimbot']['FOV'].Filled
        AimingFOVObject.Transparency = Script['Camera Aimbot']['FOV'].Transparency
        AimingFOVObject.Position = Vector2.new(Mouse.X, Mouse.Y + Offset)
        --
        SilentFOVObject.Visible = Script['Silent Aimbot']['FOV']['Visible']
        SilentFOVObject.Radius = Module.Locals.SilentFOV
        SilentFOVObject.Filled = Script['Silent Aimbot']['FOV'].Filled
        SilentFOVObject.Transparency = Script['Silent Aimbot']['FOV'].Transparency
        SilentFOVObject.Position = Vector2.new(Mouse.X , Mouse.Y + Offset)
        --
        if Script['Silent Aimbot']['FOV']['2D FOV']['Enabled'] then
            Visuals:UpdateBox()
        end
    end
end
--
do -- Math
    function Math:AngleEdge(Angle, Inset)
        local ScreenSize = Camera.ViewportSize
        local Sine = Sin(Angle)
        local Cosine = Cos(Angle)
        local Slope = (Sine / Cosine)
        local EdgeX = ScreenSize.X - Inset
        local EdgeY = ScreenSize.Y - Inset
        --
        if Sine < 0 then EdgeY = Inset end
        if Cosine < 0 then EdgeX = Inset end
        --
        local Height = (Slope * EdgeX) + (ScreenSize.y / 2) - Slope * (ScreenSize.x / 2)
        --
        return (Height > 0 and Height < ScreenSize.Y - Inset) and Vector2.new(EdgeX, Height) or Vector2.new((EdgeY - ScreenSize.Y / 2 + Slope * (ScreenSize.X / 2)) / Slope, EdgeY)
    end
    --
    function Math:Shift(Number)
        return Acos(Cos(Number * Pi)) / Pi
    end
    --
    function Math:FlatComparison(Position, BoxRotation, BoxSize)
    	return Position.X >= BoxRotation.X and
		Position.X <= BoxRotation.X + BoxSize.X and
		Position.Y >= BoxRotation.Y and
		Position.Y <= BoxRotation.Y + BoxSize.Y
    end
    --
   function Math:Quadratic(a, b, c)
        local Sqrt = b^2 - 4 * a * c
        if Sqrt < 0 then
            return nil
        end
        local Discriminant = math.sqrt(Sqrt)
        local t1 = (-b + Discriminant) / (2 * a)
        local t2 = (-b - Discriminant) / (2 * a)
        --
        if t1 >= 0 and t2 >= 0 then
            return math.min(t1, t2)
        elseif t1 >= 0 then
            return t1
        elseif t2 >= 0 then
            return t2
        end
        --
        return nil
    end
    --
    function Math:GetInterception(A, B0, v_t, v_b)
        local function getCoefficients(A_comp, B_comp, v_t_comp)
            local a = v_t_comp * v_t_comp - v_b^2
            local b = 2 * (A_comp - B_comp) * v_t_comp
            local c = (A_comp - B_comp) * (A_comp - B_comp)
            return a, b, c
        end
    
        local function solveDimension(A_comp, B_comp, v_t_comp)
            local a, b, c = getCoefficients(A_comp, B_comp, v_t_comp)
            return Math:Quadratic(a, b, c)
        end
    
        local t_x, err_x = solveDimension(A.x, B0.x, v_t.x)
        local t_y, err_y = solveDimension(A.y, B0.y, v_t.y)
        local t_z, err_z = solveDimension(A.z, B0.z, v_t.z)
    
        if not t_x or not t_y or not t_z then
            return nil, 'how did we end up here'
        end
    
        local t = math.max(t_x, t_y, t_z)
    
        local Bt = B0 + v_t * t
        return Bt, t_x, t_y, t_z
    end
end
--
do -- Color
    --[[
    function Color:Multiply(Color, Multiplier)
		return Color3.fromRGB(Color.R * Multiplier, Color.G * Multiplier, Color.B * Multiplier)
	end
    --
	function Color:Add(Color, Addition)
		return Color3.fromRGB(Color.R + Addition, Color.G + Addition, Color.B + Addition)
	end
    --
    function Color:Lerp(Value, MinColor, MaxColor)
        if Value <= 0 then return MaxColor end
        if Value >= 100 then return MinColor end
        --
        return Color3.fromRGB(
            MaxColor.R + (MinColor.R - MaxColor.R) * Value,
            MaxColor.G + (MinColor.G - MaxColor.G) * Value,
            MaxColor.B + (MinColor.B - MaxColor.B) * Value
        )
    end
    ]]
end
--
do -- Tween
    Tween.EasingStyles = {
        [Enum.EasingStyle.Linear] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Delta
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                return Delta
            end
        },
        [Enum.EasingStyle.Cubic] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 3
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 3) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (4 * Delta ^ 3)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (4 * (Delta - 1) ^ 3) + 1
                end
            end
        },
        [Enum.EasingStyle.Quad] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 2
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (-(Delta - 1) ^ 2) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (2 * Delta ^ 2)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return -(2 * (Delta - 1) ^ 2) + 1
                end
            end
        },
        [Enum.EasingStyle.Quart] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 4
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (-(Delta - 1) ^ 4) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (8 * Delta ^ 4)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return -(8 * (Delta - 1) ^ 4) + 1
                end
            end
        },
        [Enum.EasingStyle.Quint] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 5
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 5) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (16 * Delta ^ 5)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (16 * (Delta - 1) ^ 5) + 1
                end
            end
        },
        [Enum.EasingStyle.Sine] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Sin(((Pi / 2) * Delta) - (Pi / 2)) + 1
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Sin((Pi / 2) * Delta)
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                return (0.5 * Sin((Pi * Delta) - (Pi / 2))) + 0.5
            end
        },
        [Enum.EasingStyle.Exponential] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (2 ^ ((10 * Delta) - 10)) - 0.001
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return 1.001 * (-2 ^ -(10 * Delta)) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return 0.5 * (2 ^ ((20 * Delta) - 10)) - 0.0005
                elseif 0.5 <= Delta and Delta <= 1 then
                    return 0.50025 * (-2 ^ (-(20 * Delta) + 10)) + 1
                end
            end
        },
        [Enum.EasingStyle.Back] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (Delta * Delta) * (Delta * (1.70158 + 1) - 1.70158)
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 2) * ((Delta - 1) * (1.70158 + 1) + 1.70158) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (2 * (Delta * Delta)) * ((2 * Delta) * (2.5949095 + 1) - 2.5949095)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (0.5 * ((2 * Delta) - 2) ^ 2) * (((2 * Delta) - 2) * (2.5949095 + 1) + 2.5949095) + 1
                end
            end
        },
        [Enum.EasingStyle.Bounce] = {
            [Enum.EasingDirection.In] = function(Delta)
                if 0 <= Delta and Delta <= (1 / 2.75) then
                    return 7.5625 * (Delta * Delta)
                elseif (1 / 2.75) <= Delta and Delta <= (2 / 2.75) then
                    return 7.5625 * (Delta - (1.5 / 2.75)) ^ 2 + 0.75
                elseif (2 / 2.75) <= Delta and Delta <= (2.5 / 2.75) then
                    return 7.5625 * (Delta - (2.25 / 2.75)) ^ 2 + 0.9375
                elseif (2.5 / 2.75) <= Delta and Delta <= 1 then
                    return 7.5625 * (Delta - (2.625 / 2.75)) ^ 2 + 0.984375
                end
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                if 0 <= Delta and Delta <= (0.25 / 2.75) then
                    return -7.5625 * (1 - Delta - (2.625 / 2.75)) ^ 2 + 0.015625
                elseif (0.25 / 2.75) <= Delta and Delta <= (0.75 / 2.75) then
                    return -7.5625 * (1 - Delta - (2.25 / 2.75)) ^ 2 + 0.0625
                elseif (0.75 / 2.75) <= Delta and Delta <= (1.75 / 2.75) then
                    return -7.5625 * (1 - Delta - (1.5 / 2.75)) ^ 2 + 0.25
                elseif (1.75 / 2.75) <= Delta and Delta <= 1 then
                    return 1 - 7.5625 * (1 - Delta) ^ 2
                end
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= (0.125 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (2.625 / 2.75)) ^ 2 + 0.015625)
                elseif (0.125 / 2.75) <= Delta and Delta <= (0.375 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (2.25 / 2.75)) ^ 2 + 0.0625)
                elseif (0.375 / 2.75) <= Delta and Delta <= (0.875 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (1.5 / 2.75)) ^ 2 + 0.25)
                elseif (0.875 / 2.75) <= Delta and Delta <= 0.5 then
                    return 0.5 * (1 - 7.5625 * (1 - (2 * Delta)) ^ 2)
                elseif 0.5 <= Delta and Delta <= (1.875 / 2.75) then
                    return 0.5 + 3.78125 * ((2 * Delta) - 1) ^ 2
                elseif (1.875 / 2.75) <= Delta and Delta <= (2.375 / 2.75) then
                    return 3.78125 * ((2 * Delta) - (4.25 / 2.75)) ^ 2 + 0.875
                elseif (2.375 / 2.75) <= Delta and Delta <= (2.625 / 2.75) then
                    return 3.78125 * ((2 * Delta) - (5 / 2.75)) ^ 2 + 0.96875
                elseif (2.625 / 2.75) <= Delta and Delta <= 1 then
                    return 3.78125 * ((2 * Delta) - (5.375 / 2.75)) ^ 2 + 0.9921875
                end
            end
        },
        [Enum.EasingStyle.Elastic] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (-2 ^ (10 * (Delta - 1))) * Sin(((2 * Pi) * (Delta - 1 - (0.3 / 4))) / 0.3)
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (2 ^ (-10 * Delta)) * Sin(((2 * Pi) * (Delta - (0.3 / 4))) / 0.3) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return -0.5 * (2 ^ ((20 * Delta) - 10)) * Sin(((2 * Pi) * ((2 * Delta) - 1.1125)) / 0.45)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return 0.5 * (2 ^ ((-20 * Delta) + 10)) * Sin(((2 * Pi) * ((2 * Delta) - 1.1125)) / 0.45) + 1
                end
            end
        },
        [Enum.EasingStyle.Circular] = {
            [Enum.EasingDirection.In] = function(Delta)
                return -Sqrt(1 - Delta ^ 2) + 1
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Sqrt(-(Delta - 1) ^ 2 + 1)
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return -Sqrt(-Delta ^ 2 + 0.25) + 0.5
                elseif 0.5 <= Delta and Delta <= 1 then
                    return Sqrt(-(Delta - 1) ^ 2 + 0.25) + 0.5
                end
            end
        }
    }
end
--
do -- Module
    function Module:GetEquippedWeaponName(Player, Filter)
        local Character = Player.Character
        local tool = Character and Character:FindFirstChildWhichIsA('Tool') or false
        if tool then
            if Filter then
                if string.find(tool.Name, '%[') and string.find(tool.Name, '%]') and not string.find(tool.name, 'Wallet') and not string.find(tool.Name, 'Phone') then
                    local tname = string.split(string.split(tool.Name, '[')[2], ']')[1]
                    return tname
                end
            else
                local tname = tool.Name
                return tname
            end
        else
            return nil
        end
    end
    --
    function Module:GetCharacter(Player)
        return Player.Character
    end
    --
    function Module:GetHumanoid(Player, Character)
        return Character:FindFirstChildOfClass('Humanoid')
    end
    --
    function Module:GetRootPart(Player, Character, Humanoid)
        return Humanoid.RootPart
    end
    --
    function Module:GetHealth(Player, Character, Humanoid)
        if Humanoid then
            return Clamp(Humanoid.Health, 0, Humanoid.MaxHealth), Humanoid.MaxHealth
        end
    end
    --
    function Module:GetOrigin(Origin)
        if Origin == 'Head' then
            local Object, Humanoid, RootPart = Module:ValidateClient(Client)
            local Head = Object:FindFirstChild('Head')
            --
            if Head and Head:IsA('RootPart') then
                return Head.CFrame.Position
            end
        elseif Origin == 'Torso' then
            local Object, Humanoid, RootPart = Module:ValidateClient(Client)
            --
            if RootPart then
                return RootPart.CFrame.Position
            end
        end
        --
        return Workspace.CurrentCamera.CFrame.Position
    end
    --
    function Module:GetCharacterSize(Character)
        local RootPart = Module:GetClosestBodyPart(Character)
        --
        if (RootPart) then
            local TopLeft = Camera:WorldToScreenPoint(RootPart.Position - RootPart.Size / 2)
            local BottomRight = Camera:WorldToScreenPoint(RootPart.Position + RootPart.Size / 2)
            local Width = math.abs(TopLeft.X - BottomRight.X)
            local Height = math.abs(TopLeft.Y - BottomRight.Y)
            --
            return Width, Height
        end
        --
        return 0, 0 
    end
    --
    function Module:GetHitPosition(Mode)
        if Mode == 'Assist' then
            local Config = Script['Camera Aimbot']
            local Prediction = Utility:Construct('3D', Config['Prediction'])
            local HitPart = Config['Hit Part']
            --
            local Target = Module.Locals.AimAssistTarget
            if not Target or not Target.Character then return end
            --
            local Object, Humanoid, RootPart = Module:ValidateClient(Target)
            if not (Object and Humanoid and RootPart) then return end
            --
            local Hit
            if HitPart == 'Closest Part' then
                Hit = Module:GetClosestBodyPart(Object).Position
            elseif HitPart == 'Closest Point' then
                local PointScale = Config['Closest Point']['Point Scale']
                Hit = Module:GetNearestPointOnCharacter(Object, PointScale)
            else
                local BodyPart = Object[HitPart]
                if BodyPart then
                    Hit = BodyPart.Position
                end
            end
            --
            local Velocity = RootPart.Velocity
            return Hit + Velocity * Prediction
        elseif Mode == 'Redirection' then
            local Config = Script['Silent Aimbot']
            local Prediction = Config['Prediction']['Prediction']
            --
            local Target = Module.Locals.SilentAimTarget
            if not Target or not Target.Character then return end
            --
            local Object, Humanoid, RootPart = Module:ValidateClient(Target)
            --
            local HitPosition;
            local PointScale = Config['Closest Point']['Point Scale']
            local Hit = Module.Locals.Hit
            --Hit = Module:GetNearestPointOnCharacter(Object, PointScale)
            --
            if Humanoid.FloorMaterial == Enum.Material.Air and Module.Locals.Calibration.TargetState == Enum.HumanoidStateType.Jumping then
                HitPosition = Hit + RootPart.Velocity * Vector3.new(Prediction, Module.Locals.Calibration.AdjustYDimension, Prediction)
            elseif Humanoid.FloorMaterial == Enum.Material.Air then
                if Config['Prediction']['Custom Velocity']['YStabilize'][1] then
                    HitPosition = Hit + RootPart.Velocity * Vector3.new(Prediction, Prediction / Config['Prediction']['Custom Velocity']['YStabilize'][2], Prediction)
                else
                    HitPosition = Hit + RootPart.Velocity * Vector3.new(Prediction, Prediction, Prediction)
                end
            else
                HitPosition = Hit + RootPart.Velocity * Vector3.new(Prediction, Prediction, Prediction)
            end
            --
            return HitPosition
        end
    end    
    --
    function Module:BackupPrediction(t, width, height)
        local average_size = (width + height) / 2
        local base_size = 100
        local size_factor = (average_size / base_size) - 1
        size_factor = math.clamp(size_factor, -1, 1)
        local min_adjustment = 0.05
        local max_adjustment = 0.145
        local adjustment_range = max_adjustment - min_adjustment
        local adjusted_t = min_adjustment + (size_factor ^ 2) * adjustment_range
        return adjusted_t
    end
    --
    function Module:AdjustPrediction(t, width, height)
        local average_size = (width + height) / 2
        local base_size = 100
        local size_factor = (average_size / base_size) - 1
        size_factor = math.clamp(size_factor, -1, 1)
    
        local min_adjustment = 0.05
        local max_adjustment = 0.145
        local adjustment_range = max_adjustment - min_adjustment
    
        local adjustment = min_adjustment + (size_factor ^ 2) * adjustment_range
        return Vector3.new(adjustment, adjustment, adjustment) * t
    end
    --
    function Module:GetGroundLevel(position)
        local ray = Ray.new(position, Vector3.new(0, -1000, 0))
        local hitPart, hitPosition = workspace:FindPartOnRay(ray)
        --
        if hitPart then
            return hitPosition.Y
        else
            return position.Y
        end
    end
    --
    function Module:GetTriggerBotTarget()
        local Targets = {}
        local MouseLocation = Mouse
        local ForcefieldCheck, AliveCheck, VisibleCheck, WallCheck = false, false, false, false
        local Checks = {}
        --
        ForcefieldCheck = table.find(Checks, 'Forcefield Check') ~= nil
        AliveCheck = table.find(Checks, 'Alive Check') ~= nil
        VisibleCheck = table.find(Checks, 'Visible Check') ~= nil
        WallCheck = table.find(Checks, 'Wall Check') ~= nil
        --
        local PointRay = Workspace.CurrentCamera:ViewportPointToRay(MouseLocation.X, MouseLocation.Y, 0)
        local rayDirection = PointRay.Direction * 1000
        --
        for _, Player in ipairs(Players:GetPlayers()) do
            if Player ~= Client and Player.Character then
                local Object, Humanoid, RootPart = Module:ValidateClient(Player)
    
                if Object and Humanoid and RootPart then
                    -- 
                    if ForcefieldCheck and Object:FindFirstChildOfClass('ForceField') then
                        continue
                    end
                    if AliveCheck and not Module:ClientAlive(Player, Object, Humanoid) then
                        continue
                    end
                    --
                    local BodyParts = Module:GetBodyParts(Object, RootPart, false)
                    for _, Part in ipairs(BodyParts) do
                        if VisibleCheck and Part.Transparency == 1 then
                            continue
                        end
                        if WallCheck and not Module:RayCast(Part, Module:GetOrigin('Camera'), {Module:GetCharacter(Client)}) then
                            continue
                        end
                        --
                        Targets[#Targets + 1] = Part
                    end
                end
            end
        end
        local Hit, Position, Normal, Material = Workspace:FindPartOnRayWithWhitelist(Ray.new(PointRay.Origin, rayDirection), Targets, false, false)
        
        if Hit then
            Module.Locals.TriggerTarget = {
                Part = Hit,
                Position = Position,
                Material = Material
            }
        else
            Module.Locals.TriggerTarget = nil
        end
    end    
    --
    function Module:GetTriggerBotTarget2(Shared)
        local MousePosition = Vector2.new(Mouse.X, Mouse.Y)
        local ClosestPlayerData
        local Distance = math.huge
        local FOV = Shared.Radius + 35
        for _, Player in ipairs(Players:GetPlayers()) do
            if Player ~= Client and Player.Character and Player.Character:FindFirstChild('HumanoidRootPart') then

                if not Module:RayCast(Player.Character.HumanoidRootPart, Module:GetOrigin('Camera'), {Module:GetCharacter(Client)}) then
                    continue
                end


                local Position = Module:GetClosestBodyPart(Player.Character).Position
                local ScreenPosition, onScreen = workspace.CurrentCamera:WorldToViewportPoint(Position)
                if onScreen then
                    local Magnitude = (Vector2.new(ScreenPosition.X, ScreenPosition.Y) - MousePosition).Magnitude
                    if Magnitude < Distance and Magnitude < FOV then
                        ClosestPlayerData = Player
                        Distance = Magnitude
                    end
                end
            end
        end
    
        return ClosestPlayerData
    end
    --
    function Module:GetTarget(Shared)
        local ClosestPlayer
        local Distance = math.huge 
        local FOV = Shared.Radius + 100
        local MousePosition = Utility:Construct('2D', Mouse)
        --
        for _, Player in ipairs(Players:GetPlayers()) do
            if Player ~= Client and Player.Character and Player.Character:FindFirstChild('HumanoidRootPart') then
                if Find(Script['Global']['Check']['When selecting a player'], 'Visible') and not Module:RayCast(Player.Character.HumanoidRootPart, Module:GetOrigin('Camera'), {Module:GetCharacter(Client)}) then
                    continue
                end
                --
                if Find(Script['Global']['Check']['When selecting a player'], 'Knocked') and CurrentGame.Functions.KnockedFunction(Player) then
                    continue
                end
                --
                if Find(Script['Global']['Check']['When selecting a player'], 'Local Knocked') and CurrentGame.Functions.KnockedFunction(Client) then
                    continue
                end
                --
                local Position = Module:GetClosestBodyPart(Player.Character).Position
                local ScreenPosition, Visible = Camera:WorldToViewportPoint(Position)
                --
                if Visible then
                    local Magnitude = (Vector2.new(ScreenPosition.X, ScreenPosition.Y) - MousePosition).Magnitude
                    if Magnitude < Distance --[[and Magnitude < FOV]] then
                        ClosestPlayer = Player
                        Distance = Magnitude
                    end
                end
            end
        end
        --
        return ClosestPlayer
    end      
    --
    function Module:GetBodyParts(Character, RootPart, Indexes, Hitboxes)
        local Parts = {}
        local Hitboxes = Hitboxes or {'Head', 'Torso', 'Arms', 'Legs'}
        
        for _, Part in pairs(Character:GetChildren()) do
            if Part:IsA('BasePart') and Part ~= RootPart then
                local partNameLower = Part.Name:lower()
                if Find(Hitboxes, 'Head') and partNameLower:find('head') then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                
                elseif Find(Hitboxes, 'Torso') and (partNameLower:find('torso') or partNameLower:find('upper') or partNameLower:find('lower')) then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, 'Arms') and (partNameLower:find('arm') or partNameLower:find('hand') or partNameLower:find('upperarm') or partNameLower:find('lowerarm')) then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, 'Legs') and (partNameLower:find('leg') or partNameLower:find('foot') or partNameLower:find('upperleg') or partNameLower:find('lowerleg')) then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                end
            end
        end
        
        return Parts
    end    
    --
    function Module:Filter(Object)
        if string.find(Object.Name, 'Gun') then
            return
        end
        if Find({'Part', 'MeshPart', 'BasePart'}, Object.ClassName) then
            return true
        end
    end
    --
    function Module:GetClosestBodyPart(Object)
        local MousePosition = Vector2.new(Mouse.X, Mouse.Y)
        local Parts = {}
    
        for _, Part in pairs(Object:GetChildren()) do
            if Module:Filter(Part) then
                local ScreenPosition = Camera:WorldToScreenPoint(Part.Position)
                local Position = Vector2.new(ScreenPosition.X, ScreenPosition.Y) 
                
                local Distance = (MousePosition - Position).Magnitude
                
                table.insert(Parts, {
                    Part = Part,
                    Distance = Distance,
                })
            end
        end
    

        table.sort(Parts, function(a, b)
            return a.Distance < b.Distance
        end)
    

        return Parts[1] and Parts[1].Part
    end    
    --
    function Module:GetBodyParts3(Character)
        local MousePosition = Mouse
        local MouseX = MousePosition.X
        local MouseY = MousePosition.Y
        local LowestPartY = 0
        local InPart
        local CentreX = Utilities.WorldToScreen(Character.HumanoidRootPart.Position).X
        local RightFootX = Utilities.WorldToScreen(Character.RightFoot.Position).X
        local PossibleParts = {}

        for _, Part in ipairs(Character:GetChildren())do
            if not (Part:IsA('BasePart') and Part.Name ~= 'HumanoidRootPart') then
                continue
            end

            local Corners = GetCorners(Part.CFrame, Part.Size)
            local TopLeft = Corners.TopLeft
            local BottomRight = Corners.BottomRight

            if InsidePolygon(MousePosition, {
                Corners.TopLeft,
                Corners.BottomLeft,
                Corners.BottomRight,
                Corners.TopRight,
            }) then
                InPart = Part

                break
            end
            if BottomRight.Y > LowestPartY then
                LowestPartY = BottomRight.Y
            end

            local WithinYBounds = MouseY >= TopLeft.Y and MouseY <= BottomRight.Y

            if WithinYBounds then
                table.insert(PossibleParts, {
                    Part = Part,
                    TopLeft = TopLeft.X,
                    BottomRight = BottomRight.X,
                })
            end
        end

        if InPart then
            return InPart
        elseif #PossibleParts > 0 then
            if #PossibleParts == 1 then
                return PossibleParts[1].Part
            end

            local Right = MouseX > CentreX

            table.sort(PossibleParts, function(a, b)
                if Right then
                    return a.BottomRight > b.BottomRight
                else
                    return a.TopLeft < b.TopLeft
                end
            end)

            return PossibleParts[1].Part
        elseif MouseY >= LowestPartY then
            local Right = MouseX > CentreX
            local BackView = RightFootX > CentreX

            if Right then
                return BackView and Character.RightFoot or Character.LeftFoot
            else
                return BackView and Character.LeftFoot or Character.RightFoot
            end
        else
            return Character.Head
        end
    end
    --
    function Module:GetNearestPointOnCharacter(Character, Reduction)
        local Part = Module:GetClosestBodyPart(Character)
        --
        if Part then
            local ClosestPointConfig = {
                ReductionPercentage = Reduction,
                Center = false,
            }
            --
            local Center = ClosestPointConfig.Center;
            local Point = UserInputService:GetMouseLocation()
            local ReductionPercentage = ClosestPointConfig.ReductionPercentage
            --
            local PointRay = Camera:ViewportPointToRay(Point.X, Point.Y)
            local Intersection = PointRay.Origin + (PointRay.Direction * PointRay.Direction:Dot(Part.Position - PointRay.Origin))
            local Transform = Part.CFrame:PointToObjectSpace(Intersection)
            local ReducedSize = (Part.Size - (Part.Size * ReductionPercentage / 100)) * (Center and Vector3.new(1, 1, 0) or 1)
            local HalfSize = ReducedSize / 2
            --
            return Part.CFrame * Vector3.new(Clamp(Transform.X, -HalfSize.X, HalfSize.X), Clamp(Transform.Y, -HalfSize.Y, HalfSize.Y), Clamp(Transform.Z, -HalfSize.Z, HalfSize.Z))
        end
    end
    --
    function Module:ClientAlive(Player, Character, Humanoid)
        local Health, MaxHealth = Module:GetHealth(Player, Character, Humanoid)
        --
        return (Health > 0)
    end
    --
    function Module:ValidateClient(Player)
        local Object = Module:GetCharacter(Player)
        local Humanoid = (Object and Module:GetHumanoid(Player, Object))
        local RootPart = (Humanoid and Module:GetRootPart(Player, Object, Humanoid))
        --
        return Object, Humanoid, RootPart
    end
    --
    function Module:RayCast(Part, Origin, Ignore, Distance)
        local Ignore = Ignore or {}
        local Distance = Distance or 2000
        --
        local Cast = Ray.new(Origin, (Part.Position - Origin).Unit * Distance)
        local Hit = Workspace:FindPartOnRayWithIgnoreList(Cast, Ignore)
        --
        return (Hit and Hit:IsDescendantOf(Part.Parent)) == true, Hit
    end
    --
    function Module:AimAssist()
        if Script['Camera Aimbot']['Enabled'] then
            local Config = Script['Camera Aimbot']
            local Snappiness = Config['Snappiness']
            local Check = Script['Global']['Check']['Whilst a player is selected']
            local Smoothness = (Snappiness[1] == 'Classic') and (Snappiness[2] / 1000) or Snappiness[2]
            --
            local Target = Module.Locals.AimAssistTarget
            if Target and Target.Character then
                local Object, Humanoid, RootPart = Module:ValidateClient(Target)
                if Object and Humanoid and RootPart then
                    local Vec2D, Visible = Camera:WorldToViewportPoint(RootPart.Position)
                    if not Visible then
                        return
                    end
                    --
                    if Find(Check, 'Visible') and not Module:RayCast(RootPart, Module:GetOrigin('Camera'), {Module:GetCharacter(Client)}) then
                        return
                    end
                    --
                    if Find(Check, 'Knocked') and CurrentGame.Functions.KnockedFunction(Target) then
                        return
                    end
                    --
                    if Find(Check, 'Local Knocked') and CurrentGame.Functions.KnockedFunction(Client) then
                        return
                    end
                    --
                    local Predicted_Hit = Module:GetHitPosition('Assist')
                    local Hit = CFrame.new(Camera.CFrame.p, Predicted_Hit)
                    Camera.CFrame = Camera.CFrame:Lerp(Hit, Smoothness)
                end
            end
        end
    end    
    --
    function Module:Triggerbot()
        if not (Script['Trigger Bot']['Enabled'] and Module.Locals.TriggerState) then
            return
        end
    
        local Config = Script['Trigger Bot']
        local FOVBased = Config['FOV Based']
        local Weapons = Config['Weapons']
        local Character = Client.Character
        if not Character then return end
        local Tool = Character:FindFirstChildWhichIsA("Tool")
        if not Tool or not table.find(Weapons, Tool.Name) then return end
        if FOVBased then
            local Target = Module.Locals.TriggerBotTarget
            if Target and Target.Character then
                Tool:Activate()
            end
            return -- early exit
        end
    
        local Target = Mouse.Target
        if Target then
            local Parent = Target.Parent
            if Parent then
                local Humanoid = Parent:FindFirstChildOfClass("Humanoid")
                if Humanoid and Humanoid.Health > 0 and Players:GetPlayerFromCharacter(Parent) then
                    Tool:Activate()
                end
            end
        end
    end    
    --
    function Module:SilentAim()
        if Script['Silent Aimbot']['Enabled'] then
            if Script['Global']['Settings']['Optimization Mode'] == 2 then
                Module.Locals.SilentAimTarget = Module:GetTarget({
                    Radius = Module.Locals.SilentFOV
                })    
            end
            --
            local Send = {}
            --
            if Module.Locals.SilentAimTarget and Module.Locals.SilentAimTarget.Character then
                local Target = Module.Locals.SilentAimTarget
                --
                local Object, Humanoid, RootPart = Module:ValidateClient(Target)
                --
                local Screen, Visible = Camera:WorldToViewportPoint(Module:GetClosestBodyPart(Object).Position)
                --
                if not Visible then
                    return
                end
                --
                if not Module:RayCast(RootPart, Module:GetOrigin('Camera'), {Module:GetCharacter(Client)}) then
					return
				end
				--
                if CurrentGame.Functions.KnockedFunction(Target) then
					return
				end
				--
				if CurrentGame.Functions.GrabbedFunction(Target) then
					return
				end
                --         
                local FOVSize = Module.Locals.SilentFOV 
                local DistanceX = Abs(Screen.X - Mouse.X)
                local DistanceY = Abs(Screen.Y - Mouse.Y)
                local Box
                if Module.Locals.Bounding then
                    Box = Vector2.new(1000, 1000)
                else
                    Box = Vector2.new(0, 0)
                end
                local Type = Script['Silent Aimbot']['FOV']['2D FOV']['Enabled']
                local RadiusX = Type and Box.X or FOVSize
                local RadiusY = Type and Box.Y or FOVSize
                --
                local HitPosition = Module:GetHitPosition('Redirection')
                --
                Send = {
                    [1] = CurrentGame.Updater,
                    [2] = HitPosition
                }
                --
                if (RadiusX > DistanceX and RadiusY > DistanceY and (DistanceX^2 + DistanceY^2) < (1/0)^2) then
                    CurrentGame.Functions.RemotePath():FireServer(unpack(Send))
                end
            end
        end
    end
    --
    function Module:SelfMods()
        if not Client.Character then return end
        if Script['Silent Aimbot']['Weapon Speeds']['Enabled'] then
            local TName = Module:GetEquippedWeaponName(Client)
            if TName then
                if table.find(Weapons.Shotguns, TName) then
                    Module.Locals.Speed = Script['Silent Aimbot']['Weapon Speeds']['Shotguns']['Speed']
                elseif table.find(Weapons.Pistols, TName) then
                    Module.Locals.Speed = Script['Silent Aimbot']['Weapon Speeds']['Pistols']['Speed']
                else
                    Module.Locals.Speed = Script['Silent Aimbot']['Weapon Speeds']['Others'] ['Speed']
                end
            else
                Module.Locals.Speed = Script['Silent Aimbot']['Weapon Speeds']['Others'] ['Speed']
            end
            --
            local Object, Humanoid, RootPart = Module:ValidateClient(Client)
            if (Humanoid and RootPart) then
                local moveDirection = Humanoid.MoveDirection
                Module.Locals.MVector = moveDirection * Humanoid.WalkSpeed * Module.Locals.Speed
                RootPart.Velocity = Vector3.new(Module.Locals.MVector.X, RootPart.Velocity.Y, Module.Locals.MVector.Z)
            end
        end
    end
end
--
do -- Connections
     if (CurrentGame.HoodGame) then
        for i, v in pairs(Client.Backpack:GetChildren()) do
            if v:IsA('Tool') and not Module.ToolConnections[v] then
                Module.ToolConnections[v] = v.Activated:Connect(Module.SilentAim)
            end
        end
        for i, v in pairs(Client.Character:GetChildren()) do
            if v:IsA('Tool') and not Module.ToolConnections[v] then
                Module.ToolConnections[v] = v.Activated:Connect(Module.SilentAim)
            end
        end
        --
        Client.Character.ChildAdded:connect(function(v)
            if v:IsA('Tool') and not Module.ToolConnections[v] then
                Module.ToolConnections[v] = v.Activated:Connect(Module.SilentAim)
            end
        end)
        --
        Client.CharacterAdded:connect(function(v)
            for i = 1, # Module.ToolConnections, 1 do
                Module.ToolConnections[i]:Disconnect()
                Module.ToolConnections[i] = nil
            end
        v.ChildAdded:connect(function(v)
            if v:IsA('Tool') and not Module.ToolConnections[v] then
                    Module.ToolConnections[v] = v.Activated:Connect(Module.SilentAim)
                end
            end)
        end)
    end
    --
    local Pressed = false;
    --
    LPH_JIT_MAX(function()
        Utility:Connection(UserInputService.InputBegan, LPH_NO_VIRTUALIZE(function(Input, Processed)
            if not UserInputService:GetFocusedTextBox() then
                local AimAssist = Enum.KeyCode[Script['Global']['Keybind']:upper()]
                if Input.KeyCode == AimAssist then
                    Pressed = not Pressed
                    if Pressed then
                        Module.Locals.AimAssistTarget = Module:GetTarget({
                            Radius = AimingFOVObject.Radius
                        })
                    else
                        if Module.Locals.AimAssistTarget ~= nil then
                            Module.Locals.AimAssistTarget = nil
                        end
                    end
                end
                --
                if Script['Trigger Bot']['Activation']['Activation Type'] == 'Mouse' then
                    if Script['Trigger Bot']['Activation']['Activation Mode'] == "Toggle" then
                        if Input.UserInputType == Script['Trigger Bot']['Activation']['Activation Bind'] then
                            Module.Locals.TriggerState = not Module.Locals.TriggerState
                        end
                    elseif Script['Trigger Bot']['Activation']['Activation Mode'] == "Hold" then
                        if Input.UserInputType == Script['Trigger Bot']['Activation']['Activation Bind'] then
                            Module.Locals.TriggerState = true
                        end
                    end
                else
                    if Script['Trigger Bot']['Activation']['Activation Mode'] == "Toggle" then
                        if Input.KeyCode == Script['Trigger Bot']['Activation']['Activation Bind'] then
                            Module.Locals.TriggerState = not Module.Locals.TriggerState
                        end
                    elseif Script['Trigger Bot']['Activation']['Activation Mode'] == "Hold" then
                        if Input.KeyCode == Script['Trigger Bot']['Activation']['Activation Bind'] then
                            Module.Locals.TriggerState = true
                        end
                    end
                end
            end
        end))
        --
        Utility:Connection(UserInputService.InputEnded, LPH_NO_VIRTUALIZE(function(Input, Processed)
            if not UserInputService:GetFocusedTextBox() then
                if Script['Trigger Bot']['Activation']['Activation Type'] == 'Mouse' then
                    if Script['Trigger Bot']['Activation']['Activation Mode'] == "Hold" then
                        if Input.UserInputType == Script['Trigger Bot']['Activation']['Activation Bind'] then
                            Module.Locals.TriggerState = false
                        end
                    end
                else
                    if Script['Trigger Bot']['Activation']['Activation Mode'] == "Hold" then
                        if Input.KeyCode == Script['Trigger Bot']['Activation']['Activation Bind'] then
                            Module.Locals.TriggerState = false
                        end
                    end
                end
            end
        end))
        --
        local RenderStepped = RunService.RenderStepped
        local Heartbeat = RunService.Heartbeat
        --
        Utility:Connection(RenderStepped, LPH_NO_VIRTUALIZE(function()
            Module:Wrap(Module.AimAssist)
            Module:Wrap(Module.Triggerbot)
            Module:Wrap(Module.SelfMods)
            Module:Wrap(Visuals.Update)
        end))  
        --
        Utility:Connection(Heartbeat, LPH_NO_VIRTUALIZE(function()
            local SilentAimTarget = Module.Locals.SilentAimTarget
            if SilentAimTarget and SilentAimTarget.Character then
                local Character = SilentAimTarget.Character
                Module.Locals.Hit = Module:GetNearestPointOnCharacter(
                    Character,
                    Script['Silent Aimbot']['Closest Point']['Point Scale']
                )
            end
        end)) 
        --

        local Bridge, ProcessID = {serverUrl = "http://localhost:19283"}, nil
        local function sendRequest(options, timeout)
            timeout = tonumber(timeout) or math.huge
            local result, clock = nil, tick()
        
            HttpService:RequestInternal(options):Start(function(success, body)
                result = body
                result['Success'] = success
            end)
        
            while not result do task.wait()
                if (tick() - clock > timeout) then
                    break
                end
            end
        
            return result
        end
        
        function Bridge:InternalRequest(body, timeout)
            local url = self.serverUrl .. '/send'
            if body.Url then
                url = body.Url
                body["Url"] = nil
                local options = {
                    Url = url,
                    Body = body['ct'],
                    Method = 'POST',
                    Headers = {
                        ['Content-Type'] = 'text/plain'
                    }
                }
                local result = sendRequest(options, timeout)
                local statusCode = tonumber(result.StatusCode)
                if statusCode and statusCode >= 200 and statusCode < 300 then
                    return result.Body or true
                end
        
                local success, result = pcall(function()
                    local decoded = HttpService:JSONDecode(result.Body)
                    if decoded and type(decoded) == "table" then
                        return decoded.error
                    end
                end)
        
                if success and result then
                    error(result, 2)
                    return
                end
                return
            end
        
            local success = pcall(function()
                body = HttpService:JSONEncode(body)
            end) if not success then return end
        
            local options = {
                Url = url,
                Body = body,
                Method = 'POST',
                Headers = {
                    ['Content-Type'] = 'application/json'
                }
            }
        
            local result = sendRequest(options, timeout)
        
            if type(result) ~= 'table' then return end
        
            local statusCode = tonumber(result.StatusCode)
            if statusCode and statusCode >= 200 and statusCode < 300 then
                return result.Body or true
            end
        
            local success, result = pcall(function()
                local decoded = HttpService:JSONDecode(result.Body)
                if decoded and type(decoded) == "table" then
                    return decoded.error
                end
            end)
        
            if success and result then
                return
            end
        
        end

        local function is_client_loaded()
            local result = sendRequest({
                Url = Bridge.serverUrl .. "/send",
                Body = HttpService:JSONEncode({
                    ['c'] = "clt",
                    ['gd'] = "%Oxy_UNIQUE_ID%",
                }),
                Method = "POST"
            })
            if result.Body then
                return result.Body
            end
            return false
        end
        --[[
                
        ProcessID = is_client_loaded()
        while not tonumber(ProcessID) do
            ProcessID = is_client_loaded()
        end
        ]]
        --[[
                print("g__")

        local function _require(moduleScript)
            assert(typeof(moduleScript) == "Instance", "Attempted to call require with invalid argument(s). ", 2)
            assert(moduleScript.ClassName == "ModuleScript", "Attempted to call require with invalid argument(s). ", 2)
        
            local objectValue = Instance.new("ObjectValue", main_env().get_state())
            objectValue.Name = HttpService:GenerateGUID(false)
            objectValue.Value = moduleScript
        
            Bridge:InternalRequest({
                ['c'] = "um",
                ['cn'] = objectValue.Name,
                ['pid'] = tostring(25512)
            })
            objectValue:Destroy()
        
            return require(moduleScript)
        end

        local Handler = game:FindService("ReplicatedStorage").Modules.GunHandler
        local Gun = _require(Handler)
        local Offset = CFrame.new(0, 0.7, -3.8)

        Gun.getAim = function(Vector)
            if Client.Character and Client.Character:FindFirstChildWhichIsA("Tool") then
                local Muzzle = (Client.Character:FindFirstChildWhichIsA("Tool").Handle.CFrame).Position
                return (Module.Locals.Hit - Muzzle).Unit
            end
        end]]
        --
        RunService.PreRender:Connect(function()
            local scriptSettings = Script['Global']['Settings']
            local triggerBotSettings = Script['Trigger Bot']
            local silentAimSettings = Script['Silent Aimbot']
            
            if scriptSettings['Optimization Mode'] == 1 then
                Module.Locals.SilentAimTarget = Module:GetTarget({
                    Radius = Module.Locals.SilentFOV
                })
            end
        
            if triggerBotSettings['FOV Based'] then
                local triggerFOV = triggerBotSettings['FOV'] * 100
                Module.Locals.TriggerBotTarget = Module:GetTriggerBotTarget2({
                    Radius = triggerFOV
                })
            end
        
            if silentAimSettings['Prediction']['Custom Velocity']['Enabled'] then
                local silentAimTarget = Module.Locals.SilentAimTarget
                local playerCharacter = Players.LocalPlayer.Character
        
                if silentAimTarget and silentAimTarget.Character and playerCharacter then
                    local tool = playerCharacter:FindFirstChildOfClass('Tool')
                    local handle = tool and tool:FindFirstChild('Handle')
                    local shootBBGUI = handle and handle:FindFirstChild('ShootBBGUI')
        
                    if handle and shootBBGUI then
                        local humanoidRootPart = silentAimTarget.Character.HumanoidRootPart
                        local handlePosition = handle.Position
                        local origin = handlePosition + handle.CFrame:VectorToWorldSpace(shootBBGUI.StudsOffsetWorldSpace)
        
                        Module.Locals.Calibration.AutoVelocity = {
                            A = origin,
                            B0 = humanoidRootPart.Position,
                            v_t = humanoidRootPart.Velocity,
                            v_b = Utility:Sleep() * silentAimSettings['Prediction']['Custom Velocity']['Stabilization']
                        }
                        
                        local Bt, t_x, t_y, t_z = Math:GetInterception(
                            origin,
                            humanoidRootPart.Position,
                            humanoidRootPart.Velocity,
                            Module.Locals.Calibration.AutoVelocity.v_b
                        )
        
                        if Bt then
                            local predictionVector = Vector3.new(t_x, t_y, t_z)
                            local width, height = Module:GetCharacterSize(silentAimTarget)
                            silentAimSettings['Prediction']['Prediction'] = Module:BackupPrediction(predictionVector.Magnitude, width, height)
                            
                            if Script['Camera Aimbot']['Prediction']['Silent Sync'] then
                                Script['Camera Aimbot']['Prediction'].X = silentAimSettings['Prediction']['Prediction']
                                Script['Camera Aimbot']['Prediction'].Y = silentAimSettings['Prediction']['Prediction']
                                Script['Camera Aimbot']['Prediction'].Z = silentAimSettings['Prediction']['Prediction']
                            end
                            local adjustedPrediction = Module:AdjustPrediction(predictionVector, width, height)
                            if adjustedPrediction then
                                local groundLevel = Module:GetGroundLevel(Bt)
                                Bt = Vector3.new(Bt.X, math.max(Bt.Y, groundLevel), Bt.Z)
        
                                local heightAdjustment = math.max(0, Bt.Y - humanoidRootPart.Position.Y)
                                Module.Locals.Calibration.AdjustYDimension = adjustedPrediction.Y * (heightAdjustment / (Bt.Y - humanoidRootPart.Position.Y + 1))
                                Module.Locals.Calibration.TargetState = silentAimTarget.Character.Humanoid:GetState()
                            end
                        end
                    end
                end
            end
        end)        
    end)()
end

